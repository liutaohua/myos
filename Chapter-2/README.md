#在屏幕上输出helloworld
让我们用最快的方式进行一次输出，然后我们在反回来进行学习。
具体的代码参看[Src](https://github.com/liutaohua/myos/tree/master/Chapter-2/src)目录

```powershell
	cd src
	chmod +x build.sh
	./build.sh
```
执行以上命令后会生成hello.iso，我们把他设置到任何虚拟机的光盘中，启动虚拟机就能看到了，是不是很快呢？

#原理讲解
其实我们使用了一个取巧的方式，即使用[GRUB](http://baike.baidu.com/link?url=UvMLI0kDa4PmZjMMqYEpIBCunED2XidxmKW-iGpUUs6Ekl2LUgWQcvTTG8yJ40S6eztDZH2ZgmCgJGGPwD3Keq)引导的我们程序运行，那么grub是什么呢？能用grub干什么呢？grub怎么使用呢？</br>
其实每每看到一个工具我们就懵了，我还是那句话不要注重工具具体是什么，那么继续向下走！</br>
到这里就需要研究一下电脑在按下开机键的那一瞬间，电脑除了嗡嗡的开始叫唤之外还做了一些什么事情呢？
- **1.加电**
电源被打开后，电脑进入初始化过程。电源大约需要100~500毫秒产生一个“电源好”（power good）的逻辑信号，主板的定时器芯片接收到信号后，停止向CPU发出复位信号。从这时起，CPU开始工作。
- **2.执行BIOS程序**
CPU硬件逻辑设计为加电瞬间强行将CS的值置为0xFFFF,IP的值置为0x0000，CS:IP为0xFFFF0，0xFFFF0指向BIOS地址范围。BIOS的入口地址就是0xFFFF0.</br>
BIOS程序在内存最开始的位置（0x00000）用1KB的内存空间（0x00000~0x003FF）构建中断向量表，并在紧挨着它的位置用256字节的内存空间构建BIOS数据区（0x00400~0x004FF），在大约56KB以后的位置（0x0E05B）加载了8KB左右的与中断向量表相应的若干中断服务程序。</br>
中断向量表中有256个中断向量，每个中断向量占4个字节，其中两个字节是CS的值，两个字节是IP的值，每个中断向量都指向一个具体的中断服务程序。
- **3.引导自己的kernel进内存**
在上面的步骤完成之后呢，BIOS差不多工作完了，自检也完成了，这时候就会按照设定的引导顺序（例如CD,软盘，U盘等）进行工作，那么工作的内存地址就指向了**0x7C00**，为什么是这个地址呢，不知道，从Intel的8088开始就是这个地址。</br>
也就从这里开始，就可以去执行我们自己的汇编程序了，然后汇编调用C/C++程序慢慢的就进入操作系统了，是不是很激动？不过这里还会有很多学问，具体的需要自己去挖掘了！！！</br>
然后讲解一段汇编语言
``` x86asm
;标准的FAT12格式软盘专用代码
CYLS EQU 10
		ORG		0x7c00	        ;  加载的入口,origin的意思
		JMP		entry
		DB		0x90
		DB		"HELLOIPL"		;  启动区自定义名称8个字符
		DW		512				;  每个扇区大小，固定值
		DB		1				;  簇大小，也是定死的
		DW		1				;  FAT的起始位置
		DB		2				;  FAT个数，固定值
		DW		224				;  根目录大小，一般是这个值
		DW		2880			;  磁盘的大小，固定值
		DB		0xf0			;  磁盘的种类，固定值
		DW		9				;  FAT长度，固定值
		DW		18				;  1个磁道有几个扇区
		DW		2				;  磁头数，固定值（因为正反面一共两个）
		DD		0				;  不使用分区，必须是0
		DD		2880			;  重新写一次磁盘大小
		DB		0,0,0x29		;  不知道，写就对了 
		DD		0xffffffff		;  可能是卷标号
		DB		"HELLO-OS   "	;  磁盘名，11个字节
		DB		"FAT12   "		;  磁盘格式名称，8个字节
		RESB	18              ;  空出18个字节
```
这就是准备让BIOS去从软盘里面加载我们的内核程序啦，但是呢，我们常用系统的也知道，每种文件都是有自己的格式的，其实这种思想在BIOS里也是一样的，硬盘有硬盘的，光盘有光盘的，软盘有软盘的，U盘有U盘的，定义好了读取的格式之后呢，我们就要真正的去读取了，那么有疑问了，光盘和硬盘是什么样的呢，我也没研究过，自己google咯！</br>
好的那么代码继续：
``` x86asm

entry:
		MOV		AX,0			; 初始化寄存器
		MOV		SS,AX
		MOV		SP,0x7c00
		MOV		DS,AX

		MOV		AX,0x0820       ; 找一段内存里空闲的地址，用来装我们的程序，为什么是0820呢？因为这段空着
		MOV		ES,AX
		MOV		CH,0			; 柱面
		MOV		DH,0			; 磁头
		MOV		CL,2			; 扇区
readloop:
		MOV		SI,0			; 这里就是设置重试次数的
retry:
		MOV		AH,0x02			; AH=0x02 : 这里有意思，这是int 13中断的一个扩展，如果光盘硬盘就改为其他的值
		MOV		AL,1			; 1个扇区
		MOV		BX,0            ; 这里就是和ES共同寻址的地方,组合起来即为0x08200~0x83ff
		MOV		DL,0x00			; A驱动器
		INT		0x13			; 中断，让CPU去读
		JNC		next			; 这个中断是有返回值的，如果返回的为0就执行next标记之后的命令，也就是接着读软盘
		ADD		SI,1			; 如果中断返回为1，那就是出错了，记录错误次数
		CMP		SI,5			; 比较一下是不是错了5次了
		JAE		error			; SI >= 5 如果错了5次了，那就别试了，真的是没办法了
		MOV		AH,0x00         ; 要是不够5次呢，继续从新来
		MOV		DL,0x00			; A驱动器重置，要求的格式就是AH=0，DL=0然后INT 13
		INT		0x13			; 调用中断
		JMP		retry
next:
		MOV		AX,ES			; ES开始地址是0820，我们在这里使用一下AX，做个中间变量：因为不能ADD ES
		ADD		AX,0x020        ; 往后挪一下位置
		MOV		ES,AX			; 也就是ES+0x020位置，继续读一遍，如此遍历完整个软盘
		ADD		CL,1			; CL加1，CL是什么呢？扇区啊！！
		CMP		CL,18			; 这里就是比较是不是读完了18个扇区
		JBE		readloop		; CL <= 18 没读完就接着去读
		MOV		CL,1
		ADD		DH,1
		CMP		DH,2
		JB		readloop		; DH < 2 只是读完了一个磁头的，看看是不是正反都去完了
		MOV		DH,0
		ADD		CH,1
		CMP		CH,CYLS
		JB		readloop		; CH < CYLS 柱面是不是读了指定的数

; 10个柱面，2个磁头，18个扇区 10*2*18*512=180KB 已经读入内存了

fin:
		HLT						; 这个指令就是让CPU休息一下，但是，任何的外部因素还会让CPU继续运行，比如说按了下键盘
		JMP		fin				; 如果了你不小心唤醒了CPU，那么我就继续让他睡，这也是使用HLT 而不是永远死循环的好处所在，就是CPU不是一直那么忙！

error:
		MOV		SI,msg
putloop:
		MOV		AL,[SI]
		ADD		SI,1			; SI记错，加1
		CMP		AL,0            ; 比较AL 当前的状态
		JE		fin             ; 要是0 就是结束就行了
		MOV		AH,0x0e			; 这里是设置调用INT10中断时候的格式，或者说是参数，显示一个字的意思
		MOV		BX,15			; 字符颜色
		INT		0x10			; 这个中断是调用显卡的
		JMP		putloop
; 其实看了这个putloop难免有疑问 他是干嘛的，其实是在error执行的时候顺序向下执行的一段代码，可以作为独立的jmp地址，也可以就没人调用的顺着上面往下走！！！
msg:
		DB		0x0a, 0x0a		; 换行2次
		DB		"load error"    
		DB		0x0a			; 换行
		DB		0

		RESB	0x7dfe-$		; 一直到0x7dfe这个地址为止都写上0

		DB		0x55, 0xaa      ; 最后写上55AA是告诉BIOS，我其实是一个启动程序，如果没有就会报错的（固定值）
```
至此呢，我们的汇编程序就把软盘中的数据读取到内存当中了，那么接下来要怎么继续执行呢？后面要涉及到的知识比较多了，分章节吧，这章就到这里了！