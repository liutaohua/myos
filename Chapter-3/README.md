#不可不知的一些概念

## 回顾
上一章节中呢，回味起来可能有些杂乱，直接写了一堆的汇编代码，一时间理解不过来，也不知道重点在讲什么，那么这篇文章中，先回味一下上次要说清楚的东西！</br>

- **1. 0x7C00** 
 这个地址开始就代表了电脑可以从这里开始执行我们的程序了！
- **2. 中断向量**
 上一章中没有很确切的提出，但是在代码中有展示，即 INT 13， INT 10等。中断该怎么使用呢，其实官方是有格式的描述的，具体的我就不细说了，那么举个简单的例子，无非就是设置CH,DH,CL等等的值，然后最后设置完成了调用一下INT 13 或者其他中断，对应的IO设备就会工作了。
- **3. 不能停下来的CPU**
```x86asm
	 fin:
        HLT 
        JMP     fin       
```
使用该命令让CPU死循环在这里，为什么呢，因为cpu呆萌呆萌的，就是不能停，药不能停！

## 新的思考
```x86asm
	ORG 0x7c00 
```
大家还记得这个指令吧，这个命令是告诉CPU程序在内存的0x7c00地址，让CPU从内存的这个地址开始一条条的执行，但是有个问题，大家都知道现在的操作系统是多任务的，如果两个程序在分时的执行，那么还会按照我们的期望吗？</br>
事实上肯定不会了，那怎么办呢？接下来就来介绍一些枯燥的概念！

- **1. CPU实模式和保护模式**
老规矩，先不去学习这么高深莫测的东西，先来理解一下，两个模式都是干嘛的，为什么要设计他，采用他解决了什么问题，有什么优势。</br>
**实模式**：其实我也不是理解的很好，我理解看来，实模式就是CPU一加电启动之后的最初工作模式，就是处在实模式下的，为什么称为实模式，必然是后面有进化版本，进化为了**保护模式**，那么可以这么理解，实模式的存在就是为了新一代的CPU还兼容老的CPU而设置的。好的，继续思考，上面我们说了多任务的时候就会让CPU乱执行了，为什么呢？因为在实模式下，所有的段都是可以读、写和可执行的，那程序员就要考虑很多问题了，比如：如何避免用户进程访问系统空间，如何禁止进程A非法访问进程B的空间；应用程序员要精确计算程序大小避免自己的程序占用其他进程的空间，但对于运行时才能知道所需内存的程序却几乎无能为力，导致有时候程序干脆无法运行……
**寻址**：其实除了上面说到的还有另一个问题，那就是寻址。寻址是什么呢，就是CPU要去找内存里面存储的东西的方式就叫做寻址。在实模式下基本是指的8086 CPU，数据总线为 16位，地址总线为20位，那么处在实模式下所有寄存器都是16位，也就是一次最多能取2^16＝64KB数据，它能寻址的能力就是2^20=1MB，听起来很不明白的样子，大概意思就是在这个模式下，内存无论多大，只能用1M空间，举个例子就是在32位的操作系统中，无论你添加了多少G的内存，始终显示的只有4G，为啥嘞，因为2^32=4G。
**保护模式**： 上面介绍了两个比较容易理解的实模式下的问题，在CPU发展到80286开始就有了保护模式，从80386开始CPU数据总线和地址总线均为32位，而且寄存器都是32位。其实在我理解的范围中，实模式和保护模式最大的不同就是寻址更新了，那么围绕着寻址的变化，又产生了一堆新的概念。这就是相当于你开始住的房子是30O的，你父母、你老婆、你孩子、你老婆的父母都住在这30O当中，后来你发现你房子周围都是没人住的空房子，然后你就把墙开了个口子出来，这样你的房子就变成200O的了，但是你还是从原来的门进去，然后在走入各个不同的房子里，这样你的家人可以分开住了，你呢，也可以种些花花草草的。
**寻址方式**：实模式下的寻址是**“段基地址+段内偏移地址”**的方式，就是将1M的空间划分为很多的逻辑段，每个段最大64K，就相当于你买了一个储物盒，总共能存1M，然后你给他安装上了一堆抽屉，要找什么东西呢，就打开编号1,2,3的抽屉，然后往后数，第1,2,3个就是我要的东西。那么在保护模式下，自然这个规则就是要升级了，就成了**“选择子+段内偏移地址”**。那选择子又是什么呢？有什么优势、好处或者说解决什么问题呢？
**选择子**：选择子就是原来在实模式下段基址指向的就是物理内存地址的基址，但是现在保护模式下原来存储段基址这个地方变为了存储指向另一地方的偏移地址了，不再直接指向内存基址。那么指向了哪里，为什么要用选择子呢？首先说为什么要用选择子这个问题，这个不能简单来说吧，使用这种方式应该是全局来考量了，或许继续读下去就会大概明白！好的，那继续说指向了哪里了呢？在这里就采用了一种简单的结构了，不再是纯粹地址，那么把这个16个0或者1的空间分开来用，高13位可以存储2^13=8192个段描述符，剩下的3位中其中一位是TI，剩下的是RPL，TI中即记录了是GDT还是LDT，所以一共可以表示8192*2=16384个段描述符。
**GDT&LDT**：选择子指向了GDT或者LDT那么，他们是什么，干嘛用的，存在哪里呢？先说GDT，中文名称叫全局描述符表，在内存中有且只有一个，但是可以在内存中的任意位置，那么CPU怎么知道在哪里呢？在之后的80x86系列中引入了新的寄存器GDTR，用来存储GDT在内存中的开始地址和段限（就是表的大小）。关于GDT的数据结构呢，我一句两句描述不清，google或者百度都可以，看看图就很明白了，大概意思就是存着内存的基地址，或者是外键关联到了LDT。那么LDT是什么呢，中文名字叫局部描述符表，和GDT同样的结构，但是是GDT的外键表或者说是二级表。
- **A20**
 到这里呢，我们大概的寻址都知道了，但是CPU怎么进行实模式和保护模式的切换，并且变成4G的寻址呢？我们知道，实模式下使用了需要0～19号共20根地址线，寻址空间1M，那么我们要寻址4G，便是需要开启第21~32根地址线，这就是传说中的A20。那么代码里面如何实现enable A20呢？有兴趣的可以去查看更多文章，这里只讲解最简单的，但是并不是所有情况都适用的一种：
``` x86asm
	MOV ax, 0x2401
	INT 0x15	
```
- **模式切换**
上面介绍了不少概念了，说了这么多，其实就是为了模式切换做了一个铺垫，当切换到保护模式之后，我们有了更大的内存寻址空间，有了更方便多程序的GDT&LDT，那么我们该怎么切换呢?
> Intel推荐的步骤：
1）关中断，包括可屏蔽中断和不可屏蔽中断
2）使用lgdt加载GDTR
3）置cr0 的PE位，切换到保护模式
4）使用far jmp/call，提供一个同级权限的CS Selector更新CS寄存器
5）若需要使用LDT，用lldt加载LDTR
6）使用ltr加载TR
7）更新SS、DS寄存器
8）使用lidt加载IDTR
9）开中断